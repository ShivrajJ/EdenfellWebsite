import{PanSession as y}from"../pan/PanSession-43d9e51a.js";import{getGlobalLock as L}from"./utils/lock-a07836c2.js";import{isRefObject as v}from"../../utils/is-ref-object-d2e619ec.js";import{addPointerEvent as x}from"../../events/add-pointer-event-2e752970.js";import{applyConstraints as M,calcRelativeConstraints as V,resolveDragElastic as b,calcViewportConstraints as S,rebaseAxisConstraints as B,calcOrigin as k,defaultElastic as j}from"./utils/constraints-5fe67893.js";import{createBox as G}from"../../projection/geometry/models-d3b29ba1.js";import{eachAxis as g}from"../../projection/utils/each-axis-0a4d2db9.js";import{measurePageBox as T}from"../../projection/utils/measure-246770e2.js";import{extractEventInfo as w}from"../../events/event-info-ab2dff62.js";import{convertBoxToBoundingBox as R,convertBoundingBoxToBox as O}from"../../projection/geometry/conversion-31764c05.js";import{addDomEvent as U}from"../../events/add-dom-event-ec836865.js";import{calcLength as W}from"../../projection/geometry/delta-calc-cc68662e.js";import{mix as D}from"../../utils/mix-d6f4c5c1.js";import{percent as z}from"../../value/types/numbers/units-19d2ad6d.js";import{animateMotionValue as _}from"../../animation/interfaces/motion-value-c48217fa.js";import{frame as A}from"../../frameloop/index-0bf9a1a0.js";const F=new WeakMap;class at{constructor(t){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=G(),this.visualElement=t}start(t,{snapToCursor:s=!1}={}){const{presenceContext:n}=this.visualElement;if(n&&n.isPresent===!1)return;const i=r=>{this.stopAnimation(),s&&this.snapToCursor(w(r,"page").point)},e=(r,l)=>{const{drag:c,dragPropagation:u,onDragStart:m}=this.getProps();if(c&&!u&&(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=L(c),!this.openGlobalLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),g(h=>{let d=this.getAxisMotionValue(h).get()||0;if(z.test(d)){const{projection:P}=this.visualElement;if(P&&P.layout){const C=P.layout.layoutBox[h];C&&(d=W(C)*(parseFloat(d)/100))}}this.originPoint[h]=d}),m&&A.update(()=>m(r,l),!1,!0);const{animationState:p}=this.visualElement;p&&p.setActive("whileDrag",!0)},o=(r,l)=>{const{dragPropagation:c,dragDirectionLock:u,onDirectionLock:m,onDrag:p}=this.getProps();if(!c&&!this.openGlobalLock)return;const{offset:h}=l;if(u&&this.currentDirection===null){this.currentDirection=I(h),this.currentDirection!==null&&m&&m(this.currentDirection);return}this.updateAxis("x",l.point,h),this.updateAxis("y",l.point,h),this.visualElement.render(),p&&p(r,l)},a=(r,l)=>this.stop(r,l);this.panSession=new y(t,{onSessionStart:i,onStart:e,onMove:o,onSessionEnd:a},{transformPagePoint:this.visualElement.getTransformPagePoint()})}stop(t,s){const n=this.isDragging;if(this.cancel(),!n)return;const{velocity:i}=s;this.startAnimation(i);const{onDragEnd:e}=this.getProps();e&&A.update(()=>e(t,s))}cancel(){this.isDragging=!1;const{projection:t,animationState:s}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:n}=this.getProps();!n&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),s&&s.setActive("whileDrag",!1)}updateAxis(t,s,n){const{drag:i}=this.getProps();if(!n||!E(t,i,this.currentDirection))return;const e=this.getAxisMotionValue(t);let o=this.originPoint[t]+n[t];this.constraints&&this.constraints[t]&&(o=M(o,this.constraints[t],this.elastic[t])),e.set(o)}resolveConstraints(){const{dragConstraints:t,dragElastic:s}=this.getProps(),{layout:n}=this.visualElement.projection||{},i=this.constraints;t&&v(t)?this.constraints||(this.constraints=this.resolveRefConstraints()):t&&n?this.constraints=V(n.layoutBox,t):this.constraints=!1,this.elastic=b(s),i!==this.constraints&&n&&this.constraints&&!this.hasMutatedConstraints&&g(e=>{this.getAxisMotionValue(e)&&(this.constraints[e]=B(n.layoutBox[e],this.constraints[e]))})}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:s}=this.getProps();if(!t||!v(t))return!1;const n=t.current,{projection:i}=this.visualElement;if(!i||!i.layout)return!1;const e=T(n,i.root,this.visualElement.getTransformPagePoint());let o=S(i.layout.layoutBox,e);if(s){const a=s(R(o));this.hasMutatedConstraints=!!a,a&&(o=O(a))}return o}startAnimation(t){const{drag:s,dragMomentum:n,dragElastic:i,dragTransition:e,dragSnapToOrigin:o,onDragTransitionEnd:a}=this.getProps(),r=this.constraints||{},l=g(c=>{if(!E(c,s,this.currentDirection))return;let u=r&&r[c]||{};o&&(u={min:0,max:0});const m=i?200:1e6,p=i?40:1e7,h={type:"inertia",velocity:n?t[c]:0,bounceStiffness:m,bounceDamping:p,timeConstant:750,restDelta:1,restSpeed:10,...e,...u};return this.startAxisValueAnimation(c,h)});return Promise.all(l).then(a)}startAxisValueAnimation(t,s){const n=this.getAxisMotionValue(t);return n.start(_(t,n,0,s))}stopAnimation(){g(t=>this.getAxisMotionValue(t).stop())}getAxisMotionValue(t){const s="_drag"+t.toUpperCase(),n=this.visualElement.getProps(),i=n[s];return i||this.visualElement.getValue(t,(n.initial?n.initial[t]:void 0)||0)}snapToCursor(t){g(s=>{const{drag:n}=this.getProps();if(!E(s,n,this.currentDirection))return;const{projection:i}=this.visualElement,e=this.getAxisMotionValue(s);if(i&&i.layout){const{min:o,max:a}=i.layout.layoutBox[s];e.set(t[s]-D(o,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:s}=this.getProps(),{projection:n}=this.visualElement;if(!v(s)||!n||!this.constraints)return;this.stopAnimation();const i={x:0,y:0};g(o=>{const a=this.getAxisMotionValue(o);if(a){const r=a.get();i[o]=k({min:r,max:r},this.constraints[o])}});const{transformTemplate:e}=this.visualElement.getProps();this.visualElement.current.style.transform=e?e({},""):"none",n.root&&n.root.updateScroll(),n.updateLayout(),this.resolveConstraints(),g(o=>{if(!E(o,t,null))return;const a=this.getAxisMotionValue(o),{min:r,max:l}=this.constraints[o];a.set(D(r,l,i[o]))})}addListeners(){if(!this.visualElement.current)return;F.set(this.visualElement,this);const t=this.visualElement.current,s=x(t,"pointerdown",r=>{const{drag:l,dragListener:c=!0}=this.getProps();l&&c&&this.start(r)}),n=()=>{const{dragConstraints:r}=this.getProps();v(r)&&(this.constraints=this.resolveRefConstraints())},{projection:i}=this.visualElement,e=i.addEventListener("measure",n);i&&!i.layout&&(i.root&&i.root.updateScroll(),i.updateLayout()),n();const o=U(window,"resize",()=>this.scalePositionWithinConstraints()),a=i.addEventListener("didUpdate",({delta:r,hasLayoutChanged:l})=>{this.isDragging&&l&&(g(c=>{const u=this.getAxisMotionValue(c);u&&(this.originPoint[c]+=r[c].translate,u.set(u.get()+r[c].translate))}),this.visualElement.render())});return()=>{o(),s(),e(),a&&a()}}getProps(){const t=this.visualElement.getProps(),{drag:s=!1,dragDirectionLock:n=!1,dragPropagation:i=!1,dragConstraints:e=!1,dragElastic:o=j,dragMomentum:a=!0}=t;return{...t,drag:s,dragDirectionLock:n,dragPropagation:i,dragConstraints:e,dragElastic:o,dragMomentum:a}}}function E(f,t,s){return(t===!0||t===f)&&(s===null||s===f)}function I(f,t=10){let s=null;return Math.abs(f.y)>t?s="y":Math.abs(f.x)>t&&(s="x"),s}export{at as VisualElementDragControls,F as elementDragControls};
